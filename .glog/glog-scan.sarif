{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "bc8d1490-d25a-3495-ac6a-96690d855517",
              "name": "High-Risk Dockerfile Vulnerability: Lack of Non-Root User Specification",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"High-Risk Dockerfile Vulnerability: Lack of Non-Root User Specification\" is a common security vulnerability in Docker where the Dockerfile does not specify a non-root user for running the container. By default, Docker containers run as root, which means that if an attacker manages to break out of the container, they would have root access to the host system. This could lead to a variety of security issues, including unauthorized access to data, execution of arbitrary code, and denial of service.\n\n## Security Concern\n\nRunning Docker containers as root is a significant security concern because it provides the container with potentially dangerous permissions. If an attacker manages to exploit a vulnerability in the container or the application it's running, they could gain root access to the host system. This could allow them to execute arbitrary code, access sensitive data, or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it's recommended to always specify a non-root user in your Dockerfile. This can be done by adding a `USER` directive in the Dockerfile that specifies a non-root user. If the application needs to perform operations that require root permissions, consider using a least privilege model where only the necessary operations are performed as root.\n\n## Source Code Fix Recommendation\n\nHere's how you can modify the Dockerfile to specify a non-root user:\n\n```Dockerfile\nFROM eclipse-temurin:17-jdk-jammy\n\n# Create a group and user\nRUN groupadd -r nonroot && useradd -r -g nonroot nonroot\n\n# Tell docker that all future commands should run as the nonroot user\nUSER nonroot\n```\n\nIn this example, a new group and user named `nonroot` are created, and the `USER` directive is used to specify that all future commands should be run as this user.\n\n## Library Dependencies\n\nThe code example does not specify any library dependencies.\n\n## References\n\n- [CWE-250: Execution with Unnecessary Privileges](https://cwe.mitre.org/data/definitions/250.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-250",
                    "url": "https://cwe.mitre.org/data/definitions/250.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-250"
                ]
              }
            },
            {
              "id": "78f0c135-fcd8-31c1-ab65-3ddd0ad600bd",
              "name": "\"Exposed Asymmetric Private Key in Resource Files\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Exposed Asymmetric Private Key in Resource Files\" in Docker programming language refers to the situation where a private key is hard-coded or embedded within the Docker image or resource files. This private key can be used for various purposes such as SSH access, API access, decryption of sensitive data, etc. \n\n## Security Concern\n\nThis is a major security concern because if an attacker gains access to the Docker image or resource files, they can extract the private key. With the private key, they can impersonate the application, gain unauthorized access to systems, decrypt sensitive data, or perform other malicious activities. \n\n## Mitigation Advice\n\n- Never embed or hard-code private keys in Docker images or resource files. \n- Use environment variables or secure vault services to handle private keys.\n- Regularly rotate and change keys.\n- Use Docker secrets if you are using Docker Swarm.\n- Limit the exposure of sensitive information in Docker images.\n\n## Source Code Fix Recommendation\n\nThe private key in the given code should be removed. Instead, use Docker secrets or environment variables to handle the private key. \n\nFor example, you can use Docker secrets like this:\n\n```bash\necho \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzhWraqN+mJQuJ...\" | docker secret create my_secret_key -\n```\n\nThen use it in your Docker service:\n\n```bash\ndocker service  create --name=my_service --secret=my_secret_key my_image\n```\n\nIn your application, you can access this secret in the `/run/secrets/my_secret_key` file.\n\n## Library Dependencies\n\nThe code example does not provide any information about library dependencies.\n\n## References\n\n- [OWASP - Insecure Configuration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-798",
                    "url": "https://cwe.mitre.org/data/definitions/798.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-798"
                ]
              }
            },
            {
              "id": "0a84dd25-d52a-366d-8470-9d54d7141b9f",
              "name": "Exposed Asymmetric Private Key in Build Resources",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Exposed Asymmetric Private Key in Build Resources\" vulnerability refers to the situation where a private key is hard-coded or embedded within the Docker build resources. This is a serious security concern as it exposes sensitive information that could be exploited by malicious actors to gain unauthorized access to systems or data.\n\n## Security Concern\n\nPrivate keys are meant to be kept secret and used to verify the identity of the sender (in asymmetric encryption) or to decrypt data (in symmetric encryption). If a private key is exposed, it can be used by an attacker to impersonate the legitimate owner, decrypt sensitive data, or even launch further attacks. In the context of Docker, an exposed private key could allow an attacker to gain unauthorized access to the Docker container or the host system.\n\n## Mitigation Advice\n\n- Never hard-code or embed private keys in your Docker build resources or any part of your application. \n- Use environment variables or secure vault services to handle keys and other sensitive information.\n- Regularly use tools to scan your codebase for exposed keys or other sensitive information.\n\n## Source Code Fix Recommendation\n\nThe provided code is an RSA private key. It should not be exposed or hard-coded in the application. Instead, use Docker secrets or environment variables to handle such sensitive data. \n\nFor example, you can use Docker secrets as follows:\n\n```bash\necho \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzhWraqN+mJQuJ...\" | docker secret create my_secret_key -\n```\n\nThen use it in your Docker service:\n\n```bash\ndocker service  create --name my_service --secret my_secret_key my_image\n```\n\nIn your application, you can then access the secret from `/run/secrets/my_secret_key`.\n\n## Library Dependencies\n\nThe provided code does not require any library dependencies as it is a private key.\n\n## References\n\n- [OWASP - Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-798",
                    "url": "https://cwe.mitre.org/data/definitions/798.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-798"
                ]
              }
            },
            {
              "id": "488ecac0-7bce-30ec-9e03-a61591b072e1",
              "name": "Disabled CSRF Protection in Spring",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Request Forgery (CSRF) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user's web browser to perform an unwanted action on a trusted site for which the user is authenticated. \n\nIn Spring Security, CSRF protection is enabled by default. If you disable CSRF protection in your Spring application by using `.csrf().disable()`, you are making your application vulnerable to CSRF attacks.\n\n## Mitigation Advice\n\nTo mitigate CSRF vulnerabilities, you should:\n\n1. **Enable CSRF Protection**: In Spring Security, CSRF protection is enabled by default. You should not disable it. If you have disabled it for some reason, you should enable it again by removing `.csrf().disable()` from your configuration.\n\n2. **Use Anti-CSRF Tokens**: Spring Security provides built-in support for generating and validating CSRF tokens. You should use this feature to protect your forms from CSRF attacks.\n\n3. **Validate Origin and Referer Headers**: You can also mitigate CSRF attacks by validating the Origin and Referer headers of HTTP requests.\n\n## Source Code Fix Recommendation\n\nIf you have disabled CSRF protection in your Spring application, you can enable it again by removing `.csrf().disable()` from your configuration. Here is an example:\n\n```java\nhttp\n    .authorizeRequests()\n    .antMatchers(\"/login\").permitAll()\n    .anyRequest().authenticated()\n    .and()\n    .formLogin()\n    .loginPage(\"/login\")\n    .permitAll();\n```\n\n## Library Dependencies\n\nThe following library dependencies are required by the code example:\n\n- `spring-security-web`\n- `spring-security-config`\n\n## References\n\n- [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n- [Spring Security CSRF Protection](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf)\n- [CWE-352: Cross-Site Request Forgery (CSRF)](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-352",
                    "url": "https://cwe.mitre.org/data/definitions/352.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-352"
                ]
              }
            },
            {
              "id": "a0e0d878-65d8-3e2c-8dc8-e8e3afc33b5c",
              "name": "Disabled CSRF Protection in Spring",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Request Forgery (CSRF) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user's web browser to perform an unwanted action on a trusted site for which the user is authenticated. \n\nIn Spring Security, CSRF protection is enabled by default. If you disable CSRF protection in your Spring application by using `.csrf().disable()`, you are making your application vulnerable to CSRF attacks.\n\n## Mitigation Advice\n\nTo mitigate CSRF vulnerabilities, you should:\n\n1. **Enable CSRF Protection**: In Spring Security, CSRF protection is enabled by default. You should not disable it. If you have disabled it for some reason, you should enable it again by removing `.csrf().disable()` from your configuration.\n\n2. **Use Anti-CSRF Tokens**: Spring Security provides built-in support for generating and validating CSRF tokens. You should use this feature to protect your forms from CSRF attacks.\n\n3. **Validate Origin and Referer Headers**: You can also mitigate CSRF attacks by validating the Origin and Referer headers of HTTP requests.\n\n## Source Code Fix Recommendation\n\nIf you have disabled CSRF protection in your Spring application, you can enable it again by removing `.csrf().disable()` from your configuration. Here is an example:\n\n```java\nhttp\n    .authorizeRequests()\n    .antMatchers(\"/login\").permitAll()\n    .anyRequest().authenticated()\n    .and()\n    .formLogin()\n    .loginPage(\"/login\")\n    .permitAll();\n```\n\n## Library Dependencies\n\nThe following library dependencies are required by the code example:\n\n- `spring-security-web`\n- `spring-security-config`\n\n## References\n\n- [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n- [Spring Security CSRF Protection](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf)\n- [CWE-352: Cross-Site Request Forgery (CSRF)](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-352",
                    "url": "https://cwe.mitre.org/data/definitions/352.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-352"
                ]
              }
            },
            {
              "id": "428f6192-8ea6-3891-811b-85fa5c108fc9",
              "name": "Fixed Password Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nFixed Password Vulnerability in Java refers to the insecure practice of hardcoding passwords directly into the source code. This is a serious security risk because anyone who has access to the source code can easily read the password. This vulnerability can lead to unauthorized access, data breaches, and other security issues.\n\n## Mitigation Advice\n\nAvoid hardcoding passwords in your source code. Instead, use environment variables, configuration files, or secure password management solutions to store passwords. These methods allow you to change passwords without modifying and redeploying your code. \n\nEnsure that the storage method you choose is secure. For example, if you use configuration files, make sure they are not included in the version control system and are properly protected by file system permissions.\n\n## Source Code Fix Recommendation\n\nInstead of hardcoding the password like this:\n\n```java\nString password = \"password\";\n```\n\nYou can use an environment variable:\n\n```java\nString password = System.getenv(\"PASSWORD\");\n```\n\nOr a properties file:\n\n```java\nProperties prop = new Properties();\nInputStream input = new FileInputStream(\"config.properties\");\nprop.load(input);\nString password = prop.getProperty(\"password\");\n```\n\n## Library Dependencies\n\nFor the properties file example, you need the `java.util.Properties` and `java.io` libraries, which are included in the Java standard library.\n\n## References\n\n- [CWE-259: Use of Hard-coded Password](https://cwe.mitre.org/data/definitions/259.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-259",
                    "url": "https://cwe.mitre.org/data/definitions/259.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-259"
                ]
              }
            },
            {
              "id": "4dcfa34f-0a4d-3635-a9fa-7cf9cfcccb3b",
              "name": "Fixed Password Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nFixed Password Vulnerability in Java refers to the insecure practice of hardcoding passwords directly into the source code. This is a serious security risk because anyone who has access to the source code can easily read the password. This vulnerability can lead to unauthorized access, data breaches, and other security issues.\n\n## Mitigation Advice\n\nAvoid hardcoding passwords in your source code. Instead, use environment variables, configuration files, or secure password management solutions to store passwords. These methods allow you to change passwords without modifying and redeploying your code. \n\nEnsure that the storage method you choose is secure. For example, if you use configuration files, make sure they are not included in the version control system and are properly protected by file system permissions.\n\n## Source Code Fix Recommendation\n\nInstead of hardcoding the password like this:\n\n```java\nString password = \"password\";\n```\n\nYou can use an environment variable:\n\n```java\nString password = System.getenv(\"PASSWORD\");\n```\n\nOr a properties file:\n\n```java\nProperties prop = new Properties();\nInputStream input = new FileInputStream(\"config.properties\");\nprop.load(input);\nString password = prop.getProperty(\"password\");\n```\n\n## Library Dependencies\n\nFor the properties file example, you need the `java.util.Properties` and `java.io` libraries, which are included in the Java standard library.\n\n## References\n\n- [CWE-259: Use of Hard-coded Password](https://cwe.mitre.org/data/definitions/259.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-259",
                    "url": "https://cwe.mitre.org/data/definitions/259.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-259"
                ]
              }
            },
            {
              "id": "26802867-953d-3894-a91a-5ce43a52a634",
              "name": "Disabled CSRF Protection in Spring",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Request Forgery (CSRF) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user's web browser to perform an unwanted action on a trusted site for which the user is authenticated. \n\nIn Spring Security, CSRF protection is enabled by default. If you disable CSRF protection in your Spring application by using `.csrf().disable()`, you are making your application vulnerable to CSRF attacks.\n\n## Mitigation Advice\n\nTo mitigate CSRF vulnerabilities, you should:\n\n1. **Enable CSRF Protection**: In Spring Security, CSRF protection is enabled by default. You should not disable it. If you have disabled it for some reason, you should enable it again by removing `.csrf().disable()` from your configuration.\n\n2. **Use Anti-CSRF Tokens**: Spring Security provides built-in support for generating and validating CSRF tokens. You should use this feature to protect your forms from CSRF attacks.\n\n3. **Validate Origin and Referer Headers**: You can also mitigate CSRF attacks by validating the Origin and Referer headers of HTTP requests.\n\n## Source Code Fix Recommendation\n\nIf you have disabled CSRF protection in your Spring application, you can enable it again by removing `.csrf().disable()` from your configuration. Here is an example:\n\n```java\nhttp\n    .authorizeRequests()\n    .antMatchers(\"/login\").permitAll()\n    .anyRequest().authenticated()\n    .and()\n    .formLogin()\n    .loginPage(\"/login\")\n    .permitAll();\n```\n\n## Library Dependencies\n\nThe following library dependencies are required by the code example:\n\n- `spring-security-web`\n- `spring-security-config`\n\n## References\n\n- [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n- [Spring Security CSRF Protection](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf)\n- [CWE-352: Cross-Site Request Forgery (CSRF)](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-352",
                    "url": "https://cwe.mitre.org/data/definitions/352.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-352"
                ]
              }
            },
            {
              "id": "be960123-c828-3652-8eee-5197c668c55d",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n## In Context Remediation\n#### Fields to remediate: text\n### Field: text\n```\nField name: text\nValidation regex: text=\"^[a-zA-Z0-9\\s]*$\"\nMinimum length: 1\nMaximum length: 255\n```\n#### Remediation 1\nHere is a simple example of how you can validate the \"text\" parameter using Java Bean Validation and regex pattern:\n\n```java\nimport javax.validation.constraints.*;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/hawk/api/jwt\")\n@Validated\npublic class JwtItemController {\n\n    @RequestMapping(value = \"/{text}\", method = RequestMethod.GET)\n    public ResponseEntity search(@PathVariable(\"text\") @Pattern(regexp = \"^[a-zA-Z0-9\\\\s]*$\") @Size(min = 1, max = 255) String text) {\n        // Your search logic here\n        return ResponseEntity.ok().build();\n    }\n}\n```\n\nIn this example, `@Pattern` annotation is used to validate the \"text\" parameter against the provided regex pattern. `@Size` annotation is used to ensure that the length of the \"text\" parameter is between 1 and 255 characters.\n\nDependencies needed to run this application:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-validation</artifactId>\n    </dependency>\n</dependencies>\n```\n\nThis example assumes that you are using Spring Boot and Maven. The `spring-boot-starter-web` dependency is used to create a web application. The `spring-boot-starter-validation` dependency is used to enable Bean Validation.\n\n#### Remediation 1\nHere is a simple example of how you can validate the \"text\" parameter using Java Bean Validation and regex pattern. \n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\n\n@RestController\n@RequestMapping(\"/hawk/api/jwt\")\n@Validated\npublic class JwtItemController {\n\n    @RequestMapping(value = \"/{text}\", method = RequestMethod.GET)\n    public ResponseEntity search(@PathVariable(\"text\") @Pattern(regexp = \"^[a-zA-Z0-9\\\\s]*$\") @Size(min = 1, max = 255) String text) {\n        // Your search logic here\n        return ResponseEntity.ok().build();\n    }\n}\n```\n\nThis code uses the `@Pattern` annotation to apply the regex pattern and `@Size` annotation to ensure the length of the parameter value is between 1 and 255 characters. The `@Validated` annotation is used at the class level to enable validation of method parameters.\n\nDependencies needed to run this application:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-validation</artifactId>\n    </dependency>\n</dependencies>\n```\n\nThis example assumes you are using Spring Boot and Maven. The `spring-boot-starter-web` dependency is for creating web applications and the `spring-boot-starter-validation` dependency is for validation support.\n\n#### Remediation 2\nHere is a simple Java console application that validates the \"text\" parameter using the provided regex pattern and length constraints. This example uses Java's built-in Pattern and Matcher classes for regex validation.\n\n```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"test\"; // replace with user input\n        if (validateText(text)) {\n            System.out.println(\"Valid input\");\n        } else {\n            System.out.println(\"Invalid input\");\n        }\n    }\n\n    public static boolean validateText(String text) {\n        if (text.length() < 1 || text.length() > 255) {\n            return false;\n        }\n        Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9\\\\s]*$\");\n        Matcher matcher = pattern.matcher(text);\n        return matcher.matches();\n    }\n}\n```\n\nThis application doesn't require any additional dependencies to run, as it only uses built-in Java classes. To run this application, you need to have Java installed on your machine. You can replace the \"test\" string with the user input you want to validate.\n\nPlease note that this is a simple console application and doesn't include the actual method \"hawk.api.jwt.JwtItemController.public ResponseEntity search(@PathVariable(\"text\") String text)\" mentioned in the question. The validation logic can be used in the mentioned method or in a custom validation service as per your application's architecture and requirements.\n\n#### Remediation 2\nHere is a simple Java console application that validates the \"text\" parameter using a regex pattern and checks the length of the parameter value.\n\n```java\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"test123\"; // This is the text to be validated\n        System.out.println(validateText(text));\n    }\n\n    public static boolean validateText(String text) {\n        String pattern = \"^[a-zA-Z0-9\\\\s]*$\";\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(text);\n\n        if (matcher.matches() && text.length() >= 1 && text.length() <= 255) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\nThis application does not require any additional dependencies to run, as it uses only the standard Java libraries. The `java.util.regex` package is used for the regex pattern matching.\n\nTo run this application, you can simply compile the `Main.java` file and then run the `Main` class. Here are the commands to do this from the command line:\n\n```bash\njavac Main.java\njava Main\n```\n\nThis will print `true` or `false` to the console, depending on whether the \"text\" parameter is valid or not.\n\nPlease note that this is a simple console application for demonstration purposes. In a real-world application, you would likely want to handle invalid input in a more user-friendly way, such as by displaying an error message or prompting the user to enter the text again.\n\n___\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "a3ca461e-db59-3419-93ac-212539361720",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n## In Context Remediation\n#### Fields to remediate: text\n### Field: text\n```\nField name: text\nValidation regex: text=\"^[a-zA-Z0-9\\s]*$\"\nMinimum length: 1\nMaximum length: 255\n```\n#### Remediation 1\nHere is a simple example of how you can validate the \"text\" parameter using Java Bean Validation and regex pattern:\n\n```java\nimport javax.validation.constraints.*;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/hawk/api/jwt\")\n@Validated\npublic class JwtItemController {\n\n    @RequestMapping(value = \"/{text}\", method = RequestMethod.GET)\n    public ResponseEntity search(@PathVariable(\"text\") @Pattern(regexp = \"^[a-zA-Z0-9\\\\s]*$\") @Size(min = 1, max = 255) String text) {\n        // Your search logic here\n        return ResponseEntity.ok().build();\n    }\n}\n```\n\nIn this example, `@Pattern` annotation is used to validate the \"text\" parameter against the provided regex pattern. `@Size` annotation is used to ensure that the length of the \"text\" parameter is between 1 and 255 characters.\n\nDependencies needed to run this application:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-validation</artifactId>\n    </dependency>\n</dependencies>\n```\n\nThis example assumes that you are using Spring Boot and Maven. The `spring-boot-starter-web` dependency is used to create a web application. The `spring-boot-starter-validation` dependency is used to enable Bean Validation.\n\n#### Remediation 1\nHere is a simple example of how you can validate the \"text\" parameter using Java Bean Validation and regex pattern. \n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\n\n@RestController\n@RequestMapping(\"/hawk/api/jwt\")\n@Validated\npublic class JwtItemController {\n\n    @RequestMapping(value = \"/{text}\", method = RequestMethod.GET)\n    public ResponseEntity search(@PathVariable(\"text\") @Pattern(regexp = \"^[a-zA-Z0-9\\\\s]*$\") @Size(min = 1, max = 255) String text) {\n        // Your search logic here\n        return ResponseEntity.ok().build();\n    }\n}\n```\n\nThis code uses the `@Pattern` annotation to apply the regex pattern and `@Size` annotation to ensure the length of the parameter value is between 1 and 255 characters. The `@Validated` annotation is used at the class level to enable validation of method parameters.\n\nDependencies needed to run this application:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-validation</artifactId>\n    </dependency>\n</dependencies>\n```\n\nThis example assumes you are using Spring Boot and Maven. The `spring-boot-starter-web` dependency is for creating web applications and the `spring-boot-starter-validation` dependency is for validation support.\n\n#### Remediation 2\nHere is a simple Java console application that validates the \"text\" parameter using the provided regex pattern and length constraints. This example uses Java's built-in Pattern and Matcher classes for regex validation.\n\n```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"test\"; // replace with user input\n        if (validateText(text)) {\n            System.out.println(\"Valid input\");\n        } else {\n            System.out.println(\"Invalid input\");\n        }\n    }\n\n    public static boolean validateText(String text) {\n        if (text.length() < 1 || text.length() > 255) {\n            return false;\n        }\n        Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9\\\\s]*$\");\n        Matcher matcher = pattern.matcher(text);\n        return matcher.matches();\n    }\n}\n```\n\nThis application doesn't require any additional dependencies to run, as it only uses built-in Java classes. To run this application, you need to have Java installed on your machine. You can replace the \"test\" string with the user input you want to validate.\n\nPlease note that this is a simple console application and doesn't include the actual method \"hawk.api.jwt.JwtItemController.public ResponseEntity search(@PathVariable(\"text\") String text)\" mentioned in the question. The validation logic can be used in the mentioned method or in a custom validation service as per your application's architecture and requirements.\n\n#### Remediation 2\nHere is a simple Java console application that validates the \"text\" parameter using a regex pattern and checks the length of the parameter value.\n\n```java\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"test123\"; // This is the text to be validated\n        System.out.println(validateText(text));\n    }\n\n    public static boolean validateText(String text) {\n        String pattern = \"^[a-zA-Z0-9\\\\s]*$\";\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(text);\n\n        if (matcher.matches() && text.length() >= 1 && text.length() <= 255) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\nThis application does not require any additional dependencies to run, as it uses only the standard Java libraries. The `java.util.regex` package is used for the regex pattern matching.\n\nTo run this application, you can simply compile the `Main.java` file and then run the `Main` class. Here are the commands to do this from the command line:\n\n```bash\njavac Main.java\njava Main\n```\n\nThis will print `true` or `false` to the console, depending on whether the \"text\" parameter is valid or not.\n\nPlease note that this is a simple console application for demonstration purposes. In a real-world application, you would likely want to handle invalid input in a more user-friendly way, such as by displaying an error message or prompting the user to enter the text again.\n\n___\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "8017e8e9-4911-39ba-8592-070f7313345d",
              "name": "Spring Endpoint Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSpring Endpoint Vulnerability is a security flaw that can occur in applications using the Spring Framework in Java. This vulnerability can allow an attacker to gain unauthorized access to sensitive data or execute arbitrary code. It typically arises when an application exposes sensitive endpoints without proper security controls, or when it fails to validate or sanitize user input before using it in an endpoint.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should:\n\n1. Always validate and sanitize user input before using it in an endpoint. This can help prevent attacks such as SQL Injection and Cross-Site Scripting (XSS).\n2. Implement proper authentication and authorization controls for all endpoints. This can help ensure that only authorized users can access sensitive endpoints.\n3. Regularly update the Spring Framework and all other dependencies to their latest versions. This can help protect against known vulnerabilities that have been fixed in newer versions.\n4. Use security tools to regularly scan the codebase for vulnerabilities. This can help identify potential security issues before they can be exploited.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to validate user input before using it in an endpoint:\n\n```java\nimport org.springframework.web.bind.annotation.*;\nimport javax.validation.Valid;\n\n@RestController\npublic class UserController {\n\n    @PostMapping(\"/users\")\n    public User createUser(@Valid @RequestBody User user) {\n        // Your business logic here\n    }\n}\n```\n\nIn this example, the `@Valid` annotation is used to validate the `User` object before it is used. If the validation fails, a `MethodArgumentNotValidException` is thrown, which can be handled to return a meaningful error message to the client.\n\n## Library Dependencies\n\nThe following library dependencies are required for the code example:\n\n- Spring Web\n- Spring Boot Starter Validation\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)\n- [OWASP Top 10 2017: Broken Authentication](https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)\n- [CWE-287: Improper Authentication](https://cwe.mitre.org/data/definitions/287.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  },
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  },
                  {
                    "id": "CWE-287",
                    "url": "https://cwe.mitre.org/data/definitions/287.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-89",
                  "CWE-79",
                  "CWE-287"
                ]
              }
            },
            {
              "id": "19162a2c-7b93-3d4d-bad2-55b15367de4f",
              "name": "Unreliable HTTP Headers Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnreliable HTTP Headers Vulnerability in Java refers to the security risk associated with the use of unvalidated or untrusted HTTP headers in a Java application. Attackers can manipulate HTTP headers to inject malicious code, perform cross-site scripting (XSS) attacks, or bypass security controls. In the provided code snippet, the application logs the HTTP headers without any validation, which can lead to potential security risks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate all HTTP headers before using them in the application. Avoid logging sensitive information from HTTP headers such as cookies, authentication tokens, or session IDs. Use a list of known, safe HTTP headers and reject any headers not on the list. \n\n## Source Code Fix Recommendation\n\n```java\nList<String> safeHeaders = Arrays.asList(\"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\");\n\nfor (Enumeration<String> e = request.getHeaderNames(); e.hasMoreElements();) {\n    String headerName = e.nextElement();\n    if (safeHeaders.contains(headerName)) {\n        JwtLog4jController.logger.info(\"{} = {}\", headerName, request.getHeader(headerName));\n    }\n}\n```\n\nIn the above code, we first define a list of safe headers. Then, we only log the headers that are in this list.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Java Servlet API\n- Log4j\n\n## References\n\n- [CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')](https://cwe.mitre.org/data/definitions/113.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-113",
                    "url": "https://cwe.mitre.org/data/definitions/113.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-113"
                ]
              }
            },
            {
              "id": "c12fa30d-5334-3fdb-bb65-f4b803a0f215",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n## In Context Remediation\n#### Fields to remediate: text\n### Field: text\n```\nField name: text\nValidation regex: text=\"^[a-zA-Z0-9\\s]*$\"\nMinimum length: 1\nMaximum length: 255\n```\n#### Remediation 1\nHere is a simple example of how you can validate the \"text\" parameter using Java Bean Validation and regex pattern:\n\n```java\nimport javax.validation.constraints.*;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\n@Validated\npublic class JwtLog4jController {\n\n    @RequestMapping(value = \"/logRequest\", method = RequestMethod.GET)\n    public ResponseEntity logRequest(@RequestParam(\"text\") @Pattern(regexp = \"^[a-zA-Z0-9\\\\s]*$\") @Size(min = 1, max = 255) String text, HttpServletRequest request) {\n        // Your code here\n        return ResponseEntity.ok().build();\n    }\n}\n```\n\nIn this example, `@Pattern` annotation is used to apply the regex pattern to the \"text\" parameter. `@Size` annotation is used to ensure that the length of the parameter value is between 1 and 255 characters.\n\nDependencies needed to run this application:\n\n1. Spring Boot Starter Web: It is used to build web, including RESTful, applications using Spring MVC. It uses Tomcat as the default embedded container.\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n2. Hibernate Validator: It is the reference implementation of Jakarta Bean Validation. It is used to validate the parameters.\n\n```xml\n<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>6.1.5.Final</version>\n</dependency>\n```\n\n3. Spring Boot Starter Validation: It is used to autoconfigure the validation in Spring Boot applications.\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n\nPlease note that you need to add these dependencies in your `pom.xml` file if you are using Maven as your build tool.\n\n#### Remediation 2\nHere is a simple Java console application that validates the \"text\" parameter using a regex pattern and length check. This example uses the Java's built-in classes and does not require any additional dependencies.\n\n```java\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter text: \");\n        String text = scanner.nextLine();\n\n        if (validateText(text)) {\n            System.out.println(\"Text is valid\");\n        } else {\n            System.out.println(\"Text is invalid\");\n        }\n\n        scanner.close();\n    }\n\n    public static boolean validateText(String text) {\n        String regex = \"^[a-zA-Z0-9\\\\s]*$\";\n        return Pattern.matches(regex, text) && text.length() >= 1 && text.length() <= 255;\n    }\n}\n```\n\nThis application prompts the user to enter a text, then it validates the input using the `validateText` method. The `validateText` method checks if the text matches the regex pattern and if its length is between 1 and 255 characters.\n\nTo run this application, you need to have Java installed on your machine. You can compile the application using the `javac` command and run it using the `java` command. For example:\n\n```bash\njavac Main.java\njava Main\n```\n\nThis will compile the `Main.java` file and run the `Main` class. The application will then prompt you to enter a text and it will validate your input.\n\n___\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "40486eef-b7b1-333f-b81f-8dd2868526d2",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n## In Context Remediation\n#### Fields to remediate: text\n### Field: text\n```\nField name: text\nValidation regex: text=\"^[a-zA-Z0-9\\s]*$\"\nMinimum length: 1\nMaximum length: 255\n```\n#### Remediation 1\nHere is a simple example of how you can validate the \"text\" parameter using Java Bean Validation and regex pattern:\n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\n\n@RestController\n@RequestMapping(\"/hawk/api/jwt\")\npublic class JwtUserController {\n\n    @RequestMapping(value = \"/search/{text}\", method = RequestMethod.GET)\n    public ResponseEntity search(@PathVariable(\"text\") @Pattern(regexp = \"^[a-zA-Z0-9\\\\s]*$\") @Size(min = 1, max = 255) String text) {\n        // Your search logic here\n        return ResponseEntity.ok().build();\n    }\n}\n```\n\nTo run this application, you will need the following dependencies:\n\n1. Spring Boot Starter Web: It is used to build web, including RESTful, applications using Spring MVC. It uses Tomcat as the default embedded container.\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n2. Spring Boot Starter Validation: It is used to validate the input. It includes the Hibernate Validator which is the reference implementation of the validation API.\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n\nPlease note that the validation annotations (`@Pattern` and `@Size`) will not work out of the box in a Spring Boot application. You need to add `@Validated` annotation on the class level to enable method parameter validation.\n\n```java\nimport org.springframework.validation.annotation.Validated;\n\n@Validated\n@RestController\n@RequestMapping(\"/hawk/api/jwt\")\npublic class JwtUserController {\n    //...\n}\n```\n\nThis will cause Spring to throw a `MethodArgumentNotValidException` when the validation fails. You can handle this exception to return a custom error response.\n\n#### Remediation 2\nHere is a simple Java console application that validates the \"text\" parameter using the provided regex pattern and length constraints. This example uses Java's built-in Pattern and Matcher classes for regex validation.\n\n```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = \"test\"; // replace with user input\n        if (validateText(text)) {\n            System.out.println(\"Valid input\");\n        } else {\n            System.out.println(\"Invalid input\");\n        }\n    }\n\n    public static boolean validateText(String text) {\n        if (text.length() < 1 || text.length() > 255) {\n            return false;\n        }\n        Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9\\\\s]*$\");\n        Matcher matcher = pattern.matcher(text);\n        return matcher.matches();\n    }\n}\n```\n\nThis application doesn't require any additional dependencies to run, as it uses only built-in Java classes. To run this application, you need to have Java installed on your machine. You can replace the \"test\" string with the user input you want to validate.\n\nPlease note that this is a simple console application and doesn't include the actual method \"hawk.api.jwt.JwtUserController.public ResponseEntity search(@PathVariable(\"text\") String text)\" mentioned in the question. The validation logic can be used in the mentioned method or in a custom validation service as per your application's architecture and requirements.\n\n___\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "7c9cafe5-059c-3e94-b5a8-f189533e6f41",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "deabf0da-e8d4-3dd5-a80f-be0e920e77b5",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "19453c2b-f009-3b5e-a8b6-a1449264eb96",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "6067bb0c-447a-31b2-b796-9a6252877b16",
              "name": "Unreliable HTTP Headers Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnreliable HTTP Headers Vulnerability refers to the security flaw where an application trusts and uses HTTP headers without proper validation. HTTP headers are part of the HTTP request and response messages and can be manipulated by an attacker. In Java, this vulnerability can occur when the `HttpServletRequest.getHeader()` method is used to retrieve header values without validating or sanitizing them. This can lead to various attacks such as HTTP Response Splitting, Header Injection, Cross-Site Scripting (XSS), etc.\n\nIn the given code snippet, the `Authorization` header value is directly retrieved and stored in the `bearerToken` variable without any validation:\n\n```java\nString bearerToken = req.getHeader(\"Authorization\");\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate and sanitize all HTTP header values before using them. This can be done using regular expressions, whitelist validation, or by using a security library that provides these features.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using regular expressions to validate the `Authorization` header value:\n\n```java\nString bearerToken = req.getHeader(\"Authorization\");\nif (bearerToken != null && bearerToken.matches(\"Bearer [a-zA-Z0-9]{1,256}\")) {\n    // Proceed with the bearer token\n} else {\n    // Invalid or missing Authorization header\n}\n```\n\nThis code checks if the `Authorization` header value matches the pattern \"Bearer \" followed by 1 to 256 alphanumeric characters. If it doesn't match, it is considered invalid.\n\n## Library Dependencies\n\nThe given code snippet requires the following library dependencies:\n\n- `javax.servlet-api` for `HttpServletRequest`\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n\n## CWE\n\n- [CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')](https://cwe.mitre.org/data/definitions/113.html)\n- [CWE-20: Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-113",
                    "url": "https://cwe.mitre.org/data/definitions/113.html"
                  },
                  {
                    "id": "CWE-20",
                    "url": "https://cwe.mitre.org/data/definitions/20.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-113",
                  "CWE-20"
                ]
              }
            },
            {
              "id": "b7a82088-bd5e-3fdd-a445-4bc81366f8da",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "810396fb-fe08-3ef9-a2ee-4bcb84273bae",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "2bf81a81-58d8-3b9d-b949-ee19c32b807d",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "666b7120-9472-3e04-a083-36a7607f3baf",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "7637adb5-8381-3f60-95bb-bffc12d78a25",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "f6a81377-dc72-37b4-8063-248b2e6d184b",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "fe9aa732-4c49-36cc-880e-0bc26fb47ec7",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "de6afc69-2393-3eba-aeca-ced9207a260a",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "72bea607-7af1-3225-9002-5306a33caef1",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "346a775d-6fa0-3016-8317-f51a06186c61",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "0936592b-bc07-338f-b97f-b04cc765c590",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "c488398d-6373-300e-9674-8539eae45250",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "2ff77974-10f7-39fd-bb4d-2976ff215572",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "74a4a50f-e064-310c-b6a1-297fb3c6e945",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "866102c1-8960-3baa-8720-83f1f7ece441",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "c61bac12-7018-39c5-a0a5-53b13751916e",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "de285b0f-d98a-3a90-98e5-02c0c7278049",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "f0d6dca5-8af7-356b-94be-72a2b2674733",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "901e68dc-4f2f-3c07-884a-c4cddfc5c6bc",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "366256ef-be6e-352c-be3f-f013fce16efd",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "b3a0450a-084e-3032-95c9-ca960b865707",
              "name": "Found Spring endpoint",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\nThis class is a Spring Controller. All methods annotated with `RequestMapping` (as well as its shortcut annotations `GetMapping`, `PostMapping`, `PutMapping`, `DeleteMapping`, and `PatchMapping`) are reachable remotely. This class should be analyzed to make sure that remotely exposed methods are safe to expose to potential attackers.\n\nPerform input validation to ensure only properly formed data is entering the workflow in an information system, preventing malformed data from persisting in the database and triggering malfunction of various downstream components. Input validation should happen as early as possible in the data flow, preferably as soon as the data is received from the external party.\n\nData from all potentially untrusted sources should be subject to input validation, including not only Internet-facing web clients but also backend feeds over extranets, from suppliers, partners, vendors or regulators, each of which may be compromised on their own and start sending malformed data.\n\n\n## Solution (Bean Validation)\n\n```java\npublic class ExampleDto implements Serializable {\n    @Pattern(regexp = \"white list regular expression\")\n    @Size(min = minimum field size, max = maximum field size)\n    private String fieldName;\n}\n```\n\n## Solution (Validation Service or Method)\n\n```java\npublic boolean validateData(string data, String whiteListRegex) {\n    Pattern p = Pattern.compile(whiteListRegex);\n    Matcher m = p.matcher(data);\n    return m.matches();\n}\n```\n\n## In Context Remediation\n#### Fields to remediate: text\n### Field: text\n```\nField name: text\nValidation regex: text=\"^[a-zA-Z0-9\\s]*$\"\nMinimum length: 1\nMaximum length: 255\n```\n#### Remediation 1\nHere is a simple example of how you can validate the \"text\" parameter using Java Bean Validation and regex pattern. \n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\n\n@RestController\n@Validated\npublic class JwtUserController {\n\n    @RequestMapping(value = \"/searchCrappy/{text}\", method = RequestMethod.GET)\n    public ResponseEntity searchCrappy(@PathVariable(\"text\") @Pattern(regexp = \"^[a-zA-Z0-9\\\\s]*$\") @Size(min = 1, max = 255) String text) {\n        // Your code here\n        return ResponseEntity.ok().build();\n    }\n}\n```\n\nIn this example, `@Pattern` annotation is used to validate the \"text\" parameter against the provided regex pattern. `@Size` annotation is used to ensure that the length of the \"text\" parameter is between 1 and 255 characters.\n\nDependencies needed to run this application:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-validation</artifactId>\n    </dependency>\n</dependencies>\n```\n\nThis example assumes that you are using Spring Boot. The `spring-boot-starter-web` dependency is used to create a web application. The `spring-boot-starter-validation` dependency is used to enable Bean Validation support.\n\n#### Remediation 2\nHere is a simple Java console application that validates the \"text\" parameter using the provided regex pattern and length constraints. This example uses Java's built-in Pattern and Matcher classes for regex matching.\n\n```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        String text = args[0]; // get the text parameter from command line arguments\n        if (validateText(text)) {\n            System.out.println(\"Valid text\");\n        } else {\n            System.out.println(\"Invalid text\");\n        }\n    }\n\n    public static boolean validateText(String text) {\n        if (text.length() < 1 || text.length() > 255) {\n            return false;\n        }\n        Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9\\\\s]*$\");\n        Matcher matcher = pattern.matcher(text);\n        return matcher.matches();\n    }\n}\n```\n\nTo run this application, you need to have Java Development Kit (JDK) installed on your machine. You can run the application from the command line by compiling the Java file and then running the compiled class, passing the \"text\" parameter as a command line argument.\n\n```bash\njavac Main.java\njava Main \"your text here\"\n```\n\nThis application does not require any additional dependencies beyond the JDK. The regex pattern \"^[a-zA-Z0-9\\s]*$\" matches any string that contains only alphanumeric characters and spaces. The `validateText` method checks that the length of the \"text\" parameter is between 1 and 255 characters, and that it matches the regex pattern. If both conditions are met, the method returns true; otherwise, it returns false.\n\n___\n\n\n## References\n- [OWASP: REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [OWASP: Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n- [OWASP: Bean Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Bean_Validation_Cheat_Sheet.html)\n\n\n"
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "0c33f4e9-6f80-3ed4-abb1-38558b9ef925",
              "name": "Unreliable HTTP Headers Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnreliable HTTP Headers Vulnerability in Java refers to the security risk associated with the use of HTTP headers in a way that can be manipulated by an attacker. HTTP headers are part of the HTTP request and response messages and they carry important information about the request or response. If an application relies on these headers for critical functionality without validating or sanitizing them, it can be exploited by an attacker. For instance, an attacker can manipulate headers to bypass authentication, perform cross-site scripting (XSS) attacks, or even execute arbitrary code.\n\nIn the provided code snippet, the application is retrieving a header value directly from the HTTP request without any validation:\n\n```java\nreturn request.getHeader(authHeaderName);\n```\n\nThis is a potential security risk as the `authHeaderName` could be manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Avoid using HTTP headers for critical functionality as much as possible.\n2. Always validate and sanitize any data retrieved from HTTP headers.\n3. Use secure coding practices and libraries that provide built-in protection against common web vulnerabilities.\n\n## Source Code Fix Recommendation\n\nA simple fix would be to validate the `authHeaderName` before using it:\n\n```java\nif (isValid(authHeaderName)) {\n    return request.getHeader(authHeaderName);\n} else {\n    throw new IllegalArgumentException(\"Invalid header name\");\n}\n```\n\nIn this code, `isValid()` is a hypothetical function that checks if the header name is valid. You should replace it with your own validation logic.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `javax.servlet-api` for the `HttpServletRequest` object.\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')](https://cwe.mitre.org/data/definitions/113.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-113",
                    "url": "https://cwe.mitre.org/data/definitions/113.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-113"
                ]
              }
            },
            {
              "id": "a3a14f30-d332-32a2-8bbc-e79e3ff8a6ea",
              "name": "Violation of Trust Boundary",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Violation of Trust Boundary\" is a vulnerability that occurs when an application does not properly enforce boundaries between the data that is controlled by an outside user and the data that is within the control of the application. This can lead to a variety of security issues, such as unauthorized access to sensitive data, execution of arbitrary code, or even complete takeover of the system.\n\nIn the context of Java programming, this vulnerability can occur when an application uses the `setAttribute()` method to store sensitive data, such as a security context, in a location that can be accessed by an outside user. In the provided sink, the application is storing the security context in a Spring Security attribute, which could potentially be accessed by an outside user.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that sensitive data is not stored in a location that can be accessed by an outside user. Instead, sensitive data should be stored in a secure location, such as a server-side session, and should only be accessed through secure methods.\n\nIn addition, you should ensure that your application properly validates and sanitizes all user input. This can help to prevent a variety of security issues, including SQL injection, cross-site scripting (XSS), and command injection attacks.\n\n## Source Code Fix Recommendation\n\nInstead of storing the security context in a Spring Security attribute, you should store it in a server-side session. Here is an example of how you can do this:\n\n```java\nHttpSession session = request.getSession(true);\nSecurityContext sc = SecurityContextHolder.getContext();\nsession.setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY, sc);\n```\n\n## Library Dependencies\n\nThe following libraries are required for the code example to execute properly:\n\n- `spring-security-core`\n- `spring-security-web`\n\n## References\n\n- [OWASP Top 10-2017 A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-501: Trust Boundary Violation](https://cwe.mitre.org/data/definitions/501.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-501",
                    "url": "https://cwe.mitre.org/data/definitions/501.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-501"
                ]
              }
            },
            {
              "id": "6874cf9b-e97b-39bc-8156-8ff0d1172299",
              "name": "XSS Vulnerability from User-Controlled Data in HTML String",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided JavaScript code, the vulnerability arises from the use of template literals to construct a string that includes user-controlled data (`paramsValues.get(paramName)`). If an attacker can control the `paramName` value, they could potentially inject malicious scripts.\n\n## Mitigation Advice\n\nTo mitigate XSS vulnerabilities, you should:\n\n- Use frameworks that automatically escape XSS by design, such as Ruby on Rails, React JS, etc.\n- Escape untrusted HTTP request data based on the context in the HTML output (body, attribute, JavaScript, CSS, or URL).\n- Apply context-sensitive encoding when modifying the browser document on the client side.\n- Validate, filter, or sanitize user-generated inputs.\n\n## Source Code Fix Recommendation\n\nIn this specific case, you can mitigate the vulnerability by properly encoding the user-controlled data before including it in the HTML string. Here's a simple fix using the `encodeURI` function:\n\n```javascript\nreturn `${hawkConf[\"app\"][\"host\"]}${encodeURI(paramsValues.get(paramName))}`\n```\n\n## Library Dependencies\n\nThe provided code does not seem to require any specific library dependencies.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "c715549b-a9b6-3a33-b131-6d91bbc2d851",
              "name": "XSS Vulnerability from User-Controlled Data in HTML String",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided code snippet, the application is vulnerable to XSS because it's directly using user-controlled data in an HTML string without proper sanitization or encoding.\n\n## Mitigation Advice\n\nTo mitigate XSS vulnerabilities, it's recommended to:\n\n- Use frameworks that automatically escape XSS by design, such as Ruby on Rails, React JS, etc.\n- Escape untrusted HTTP request data based on the context in the HTML output (body, attribute, JavaScript, CSS, or URL).\n- Apply context-sensitive encoding when modifying the browser document on the client side.\n- Validate, filter, or sanitize user-generated input to prevent malicious data from being executed as code in the browser.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you can use the `encodeURIComponent` function to encode user-controlled data:\n\n```javascript\nstr += `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`;\n```\n\nThis function encodes special characters. In addition, it encodes the following characters: `, / ? : @ & = + $ #`.\n\n## Library Dependencies\n\nThe provided code snippet does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "10fb63e3-85d0-347e-9e79-c3419a3b0650",
              "name": "Unsecured Cookie Detected",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unsecured Cookie Detected\" is a vulnerability that occurs when a web application does not properly secure its cookies. This can lead to unauthorized access to sensitive information stored in the cookies, such as user session identifiers, which can lead to session hijacking and other serious security issues.\n\nIn the provided Java code, a new cookie named \"XLOGINID\" is being created and added to the HTTP response without any security flags. This means that the cookie can be transmitted over unsecured HTTP connections, making it vulnerable to interception and tampering.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always secure your cookies by setting the `Secure` and `HttpOnly` flags. The `Secure` flag ensures that the cookie is only sent over HTTPS, preventing it from being intercepted during transmission. The `HttpOnly` flag prevents the cookie from being accessed through client-side scripts, reducing the risk of cross-site scripting (XSS) attacks.\n\n## Source Code Fix\n\nHere is how you can modify the provided code to secure the cookie:\n\n```java\nimport javax.servlet.http.Cookie;\n\nCookie cookie = new Cookie(\"XLOGINID\", cookieCode);\ncookie.setSecure(true);\ncookie.setHttpOnly(true);\nresp.addCookie(cookie);\n```\n\n## Library Dependencies\n\nThe provided code requires the following library to execute properly:\n\n- `javax.servlet.http.Cookie`\n\n## References\n\n- [CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute](https://cwe.mitre.org/data/definitions/614.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-614",
                    "url": "https://cwe.mitre.org/data/definitions/614.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-614"
                ]
              }
            },
            {
              "id": "4923fc7d-94f8-3cc9-89f2-91769612e757",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided JavaScript code, the potential XSS vulnerability arises from the use of template literals to include user-controlled data (`msg.requestHeader`, `msg.requestBody`, `msg.responseHeader`, `msg.responseBody`) in an HTML string without any form of sanitization or encoding.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always escape untrusted HTTP request data based on the HTML context (body, attribute, JavaScript, CSS, or URL) that the data will be placed into. \n\nIn JavaScript, you can use functions like `encodeURIComponent()`, `encodeURI()`, or `escape()` to encode user-controlled data. However, these are not sufficient to prevent all XSS attacks. It's recommended to use a trusted library that makes it easier to encode data safely.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using the `escape()` function:\n\n```javascript\nreturn `${escape(msg.requestHeader)}\\r\\n\\r\\n${escape(msg.requestBody)}\\r\\n---\\r\\n${escape(msg.responseHeader)}\\r\\n\\r\\n${escape(msg.responseBody)}`;\n```\n\n## Library Dependencies\n\nThe provided code does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "78f0c135-fcd8-31c1-ab65-3ddd0ad600bd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Exposed Asymmetric Private Key in Resource Files\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/resources/keyStore.pem",
                  "uriBaseId": "ROOTPATH"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 1,
                  "endLine": 31,
                  "endColumn": 1,
                  "snippet": {
                    "text": "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzhWraqN+mJQuJ\n+JKBb4tcwJ1m5lTYccZbvsvCkCdQF0Ge0PhqYK8I9XyFTMPDv88h1Q+qDVlkqV5v\nVKFeR6v/REOH0AFJ4qC/mmhb9h3LnvyU6KtsZ4KWUfNfGhbpYxVTLU98CzqO9VTN\nxVCreXkTWCpbFTHGyb31sNG3xobL5PLgtNPECaDTJeiY0Z2ID/6fARWv4zn0luQS\ngDRLE2K73i2YjgD05OwdNRHklfnQKZLdkXX/TMVqzNT0Hg9a/thBQAIuozwK1SVs\nOfry/xFGWii19nDR4PaYjT0Xt/BQIt6tk4rg2Xt1XrTRxzrdzSIpHPQoO9g1nl9F\n/yoaq87VAgMBAAECggEBAK47UMfDmrxvu9E+lUJWdhWhQ6L47WPcmL22YaAFtIIA\n8EkpW9Ay4e56A06EgINdh7S4SqmqpxYRY3v90Vfli8MGB9yqPnXtJEKRo7ONHMHh\nHheP8cAWfiFSjDfC5HXDGpFNqpUjeMQCyzmixXaHQMFLkmAwI81hQ6JO6FvKrEz5\n2WCja/OyBwlAybpZgzKTkKGXSBY8NrcWfm8QEZHaJkDDw0aBhgANB2+He6dJCfyM\n1NqauTvbTjeYb5XXQffMhCbYmZM0+f/R4vF3N39lGkcaHMCh9r7c1+lsUKT4oT6p\nYRwvUP3uzBfKIUJJCqw4PD30JDcT+CxMnXn27KLu0cECgYEA3zKxAfOAySz7vVmV\nnIc8p7q09QGOYkx1m3+gAyCJqUAUX1ypPw+C3rk9zAThnZYsJL//5daxw8FMXCSm\nJkcMB2Sj0FKhiqIi+LEgu0tni4COVaTTCG27IXs9sgZTyPGQIwjoT3NhB1Bt3Ksi\nh7hnv8fHDPXzv7ptYpwfyRWDZpkCgYEAzed8S37GeZGbW5qqDyuKnWjG/UPPeTrw\n5DjCSyBVEF3kZrMSc+O2bgf87VFOHBTORzr5r0zNWy12r9w3Ky02z4cxeujulihz\n9ObY6aim6iRHwYpB0D5Eqs4R6mK189bKb9OD/F7USGy//tPP7hqfQC1JHJed4fwR\n0esIOFJ5250CgYAKwVCSPX+ZMhe3WhfBgSrFElQh8j9AMVsBcTbur6SyiSnyJm7p\nYP/3Z4m4yQtuIoxiAPZ9xsiuHCRn1ERFV+sWeB0Ertal7YYt4asoG0wUBs/VBKo+\nn7sCtAOXDoL/DdTaO1WmbnLgfVmt5nk1fQdS0HehAkEKnhsjQ06sy+KXEQKBgBuU\n9b57NgUU7zW/KyarE39wiK9mhQVdUuWPgN9lbl+p5C2psUAa8dYdddEoggka9GLw\nUIAeDqg3F94I5s7+2IfGOWeYilVNB/N3dPkf4XQd9grEBXrqzHIA9r9qB6upSybd\ns6F75n3pK3LsVr8zi7+iEVgmKz0Zch2nmUtKKQ61AoGAPHVizunifBjtKaQHFBdr\np5llidfBU6S0DsdRBG2PYxHB4TMc16gYpZicCIOsTavjS++ZBdtcL1VFiutavKop\nJhZbwH6PR76GJbdwUS3pl8s5+w21KtMxOwR8Oqoc/Sr+Bno37Yek/5CaVwnysEd0\nGWwVDi+xxRJnUIsVzdUBP+8="
                  }
                }
              },
              "message": {
                "text": "src/main/resources/keyStore.pem"
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "763419e3ed38141479848303552de3ddc33fa1609b3e8e08b8224690218d0e2b",
            "glog-pfp-ruleFileCode/v1": "a84fe89386abd576deb23381498aee92486568e5436bedb386938e8b5e000a45"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a84fe89386abd576deb23381498aee92486568e5436bedb386938e8b5e000a45"
          }
        },
        {
          "ruleId": "bc8d1490-d25a-3495-ac6a-96690d855517",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "High-Risk Dockerfile Vulnerability: Lack of Non-Root User Specification"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Dockerfile",
                  "uriBaseId": "ROOTPATH"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 1,
                  "endLine": 1,
                  "endColumn": 1,
                  "snippet": {
                    "text": "FROM eclipse-temurin:17-jdk-jammy"
                  }
                }
              },
              "message": {
                "text": "Dockerfile"
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cc01dfd2946e50dff6861d3988ed694f1210186d23722393917794fcdaf7983f",
            "glog-pfp-ruleFileCode/v1": "a2db13e2cbbdd619dccaa0fa3203030ef1c36f7243e3535676d08791f9bbd155"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a2db13e2cbbdd619dccaa0fa3203030ef1c36f7243e3535676d08791f9bbd155"
          }
        },
        {
          "ruleId": "0a84dd25-d52a-366d-8470-9d54d7141b9f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Exposed Asymmetric Private Key in Build Resources"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "build/resources/main/keyStore.pem",
                  "uriBaseId": "ROOTPATH"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 1,
                  "endLine": 31,
                  "endColumn": 1,
                  "snippet": {
                    "text": "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzhWraqN+mJQuJ\n+JKBb4tcwJ1m5lTYccZbvsvCkCdQF0Ge0PhqYK8I9XyFTMPDv88h1Q+qDVlkqV5v\nVKFeR6v/REOH0AFJ4qC/mmhb9h3LnvyU6KtsZ4KWUfNfGhbpYxVTLU98CzqO9VTN\nxVCreXkTWCpbFTHGyb31sNG3xobL5PLgtNPECaDTJeiY0Z2ID/6fARWv4zn0luQS\ngDRLE2K73i2YjgD05OwdNRHklfnQKZLdkXX/TMVqzNT0Hg9a/thBQAIuozwK1SVs\nOfry/xFGWii19nDR4PaYjT0Xt/BQIt6tk4rg2Xt1XrTRxzrdzSIpHPQoO9g1nl9F\n/yoaq87VAgMBAAECggEBAK47UMfDmrxvu9E+lUJWdhWhQ6L47WPcmL22YaAFtIIA\n8EkpW9Ay4e56A06EgINdh7S4SqmqpxYRY3v90Vfli8MGB9yqPnXtJEKRo7ONHMHh\nHheP8cAWfiFSjDfC5HXDGpFNqpUjeMQCyzmixXaHQMFLkmAwI81hQ6JO6FvKrEz5\n2WCja/OyBwlAybpZgzKTkKGXSBY8NrcWfm8QEZHaJkDDw0aBhgANB2+He6dJCfyM\n1NqauTvbTjeYb5XXQffMhCbYmZM0+f/R4vF3N39lGkcaHMCh9r7c1+lsUKT4oT6p\nYRwvUP3uzBfKIUJJCqw4PD30JDcT+CxMnXn27KLu0cECgYEA3zKxAfOAySz7vVmV\nnIc8p7q09QGOYkx1m3+gAyCJqUAUX1ypPw+C3rk9zAThnZYsJL//5daxw8FMXCSm\nJkcMB2Sj0FKhiqIi+LEgu0tni4COVaTTCG27IXs9sgZTyPGQIwjoT3NhB1Bt3Ksi\nh7hnv8fHDPXzv7ptYpwfyRWDZpkCgYEAzed8S37GeZGbW5qqDyuKnWjG/UPPeTrw\n5DjCSyBVEF3kZrMSc+O2bgf87VFOHBTORzr5r0zNWy12r9w3Ky02z4cxeujulihz\n9ObY6aim6iRHwYpB0D5Eqs4R6mK189bKb9OD/F7USGy//tPP7hqfQC1JHJed4fwR\n0esIOFJ5250CgYAKwVCSPX+ZMhe3WhfBgSrFElQh8j9AMVsBcTbur6SyiSnyJm7p\nYP/3Z4m4yQtuIoxiAPZ9xsiuHCRn1ERFV+sWeB0Ertal7YYt4asoG0wUBs/VBKo+\nn7sCtAOXDoL/DdTaO1WmbnLgfVmt5nk1fQdS0HehAkEKnhsjQ06sy+KXEQKBgBuU\n9b57NgUU7zW/KyarE39wiK9mhQVdUuWPgN9lbl+p5C2psUAa8dYdddEoggka9GLw\nUIAeDqg3F94I5s7+2IfGOWeYilVNB/N3dPkf4XQd9grEBXrqzHIA9r9qB6upSybd\ns6F75n3pK3LsVr8zi7+iEVgmKz0Zch2nmUtKKQ61AoGAPHVizunifBjtKaQHFBdr\np5llidfBU6S0DsdRBG2PYxHB4TMc16gYpZicCIOsTavjS++ZBdtcL1VFiutavKop\nJhZbwH6PR76GJbdwUS3pl8s5+w21KtMxOwR8Oqoc/Sr+Bno37Yek/5CaVwnysEd0\nGWwVDi+xxRJnUIsVzdUBP+8="
                  }
                }
              },
              "message": {
                "text": "build/resources/main/keyStore.pem"
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "044d96f69749663b3e288898f298f05c2023c362b63a0dbcd1f606b7997f7256",
            "glog-pfp-ruleFileCode/v1": "539b675102218aa8a3367e1a8505d609fbac447e0848521d20cc45f6f3556dea"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "539b675102218aa8a3367e1a8505d609fbac447e0848521d20cc45f6f3556dea"
          }
        },
        {
          "ruleId": "488ecac0-7bce-30ec-9e03-a61591b072e1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Disabled CSRF Protection in Spring"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/MultiHttpSecurityConfig.java"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 21,
                  "endLine": 112,
                  "endColumn": 37,
                  "snippet": {
                    "text": ".csrf().disable()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "configure(HttpSecurity)",
                  "fullyQualifiedName": "hawk.MultiHttpSecurityConfig$BasicAuthWebSecurityConfigurerAdapter.configure(HttpSecurity)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "3d6cb07acb07c85b528ce3a12662052122cc32c51b16e3f1de22d4fdbff0ba42",
            "glog-pfp-ruleFileCode/v1": "eaf038604c4201c4fc292f0ebd417952d6416cc109da365659fe9c04cf2c44c5"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "eaf038604c4201c4fc292f0ebd417952d6416cc109da365659fe9c04cf2c44c5"
          }
        },
        {
          "ruleId": "a0e0d878-65d8-3e2c-8dc8-e8e3afc33b5c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Disabled CSRF Protection in Spring"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/MultiHttpSecurityConfig.java"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 25,
                  "endLine": 50,
                  "endColumn": 41,
                  "snippet": {
                    "text": ".csrf().disable()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "configure(HttpSecurity)",
                  "fullyQualifiedName": "hawk.MultiHttpSecurityConfig$JwtWebSecurityConfigurationAdapter.configure(HttpSecurity)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "22212ae4381ea4820f51e3161404ea45e430560c13d2787323fd29fe857b467e",
            "glog-pfp-ruleFileCode/v1": "ea0f4f8c7ae5e271da1ffd0734cb31c47dd602fadcb458b2162d7834ebbce4bc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ea0f4f8c7ae5e271da1ffd0734cb31c47dd602fadcb458b2162d7834ebbce4bc"
          }
        },
        {
          "ruleId": "428f6192-8ea6-3891-811b-85fa5c108fc9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Fixed Password Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/MultiHttpSecurityConfig.java"
                },
                "region": {
                  "startLine": 160,
                  "startColumn": 35,
                  "endLine": 160,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\"password\""
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "userDetailsService()",
                  "fullyQualifiedName": "hawk.MultiHttpSecurityConfig.userDetailsService()",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "41a17364c95a127aa88d2fac1edd9675a3a27e30ba6fb2be27372bfdf3999e02",
            "glog-pfp-ruleFileCode/v1": "c98cfeee8a24b03c411384a1b643842a8af3b0ed7cb79b60ea55a959bfb2b541"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c98cfeee8a24b03c411384a1b643842a8af3b0ed7cb79b60ea55a959bfb2b541"
          }
        },
        {
          "ruleId": "4dcfa34f-0a4d-3635-a9fa-7cf9cfcccb3b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Fixed Password Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/MultiHttpSecurityConfig.java"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 35,
                  "endLine": 167,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\"password\""
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "userDetailsService()",
                  "fullyQualifiedName": "hawk.MultiHttpSecurityConfig.userDetailsService()",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "bd2e6f161e0b243b003d47635c9e14628085d49c3b8ef8db1eb8e425c1db14a9",
            "glog-pfp-ruleFileCode/v1": "ac48f2b67183410c5c0bba2916bb6020e399e01e2e87d7a538b0d52d5b6218db"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ac48f2b67183410c5c0bba2916bb6020e399e01e2e87d7a538b0d52d5b6218db"
          }
        },
        {
          "ruleId": "26802867-953d-3894-a91a-5ce43a52a634",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Disabled CSRF Protection in Spring"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/MultiHttpSecurityConfig.java"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 21,
                  "endLine": 91,
                  "endColumn": 37,
                  "snippet": {
                    "text": ".csrf().disable()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "configure(HttpSecurity)",
                  "fullyQualifiedName": "hawk.MultiHttpSecurityConfig$TokenWebSecurityConfigurationAdapter.configure(HttpSecurity)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c3e38182cd4a51ab50fc1c174fea0fa12003de2061493b83b807b08483ba5b23",
            "glog-pfp-ruleFileCode/v1": "483b9790c99624acb309a9c505f0ab073dee23360e8fcff2915bdd0beee30861"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "483b9790c99624acb309a9c505f0ab073dee23360e8fcff2915bdd0beee30861"
          }
        },
        {
          "ruleId": "be960123-c828-3652-8eee-5197c668c55d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.api.jwt.JwtItemController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtItemController.java"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 9,
                  "endLine": 42,
                  "endColumn": 100,
                  "snippet": {
                    "text": "SearchResult result = new SearchResult(search.getSearchText(), searchService.search(search))"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "search(Search)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtItemController.search(Search)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c6396451da64cfe367e8cc05f8950c0d539ede0bf0a9e4c1e5fb9196ff7fca9a",
            "glog-pfp-ruleFileCode/v1": "76c095814449437855ebf103205f05af5c206b8fc6eef79c20133549490c6153"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "76c095814449437855ebf103205f05af5c206b8fc6eef79c20133549490c6153"
          }
        },
        {
          "ruleId": "a3ca461e-db59-3419-93ac-212539361720",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.api.jwt.JwtItemController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtItemController.java"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 9,
                  "endLine": 36,
                  "endColumn": 40,
                  "snippet": {
                    "text": "Search search = new Search(text)"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "search(String)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtItemController.search(String)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "bc16f52d740649639b81d23f0c878dee99fd251ba3cff31f875776d0e103854a",
            "glog-pfp-ruleFileCode/v1": "198590dc467cd1745b2da24838a33e7f4b6985380d1ce04660d048b5b058872a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "198590dc467cd1745b2da24838a33e7f4b6985380d1ce04660d048b5b058872a"
          }
        },
        {
          "ruleId": "8017e8e9-4911-39ba-8592-070f7313345d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Spring Endpoint Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtAuthController.java"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 13,
                  "endLine": 45,
                  "endColumn": 48,
                  "snippet": {
                    "text": "String username = data.getUsername()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "signin(AuthenticationRequest)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtAuthController.signin(AuthenticationRequest)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7bc2428356dbb858afd2f9e7ee03aa44bbd072c050f81beb4fb859b60c324017",
            "glog-pfp-ruleFileCode/v1": "634f2f08a7bda2ef1e60bed3acc6ed055db5ec542223aac5b06409a28672ca87"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "634f2f08a7bda2ef1e60bed3acc6ed055db5ec542223aac5b06409a28672ca87"
          }
        },
        {
          "ruleId": "19162a2c-7b93-3d4d-bad2-55b15367de4f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Unreliable HTTP Headers Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtLog4jController.java"
                },
                "region": {
                  "startLine": 24,
                  "snippet": {
                    "text": "JwtLog4jController.logger.info(\"{} = {}\", it, request.getHeader(it))"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "logRequest(String, HttpServletRequest)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtLog4jController.logRequest(String, HttpServletRequest)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "63c20839bb6ace9a6809a18be74d50f96fe6315d67c66c8415cdb10ef1e93fba",
            "glog-pfp-ruleFileCode/v1": "0bc3d5d183d38801f3ea48489b48967cd7dd8bfad268368d5eb44adad8b1a98b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0bc3d5d183d38801f3ea48489b48967cd7dd8bfad268368d5eb44adad8b1a98b"
          }
        },
        {
          "ruleId": "c12fa30d-5334-3fdb-bb65-f4b803a0f215",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.api.jwt.JwtLog4jController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtLog4jController.java"
                },
                "region": {
                  "startLine": 21,
                  "endLine": 28,
                  "snippet": {
                    "text": "Enumeration headers = request.getHeaderNames()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "logRequest(String, HttpServletRequest)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtLog4jController.logRequest(String, HttpServletRequest)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4b488e2069ac594cc1e36ffd0f5d5f69296de0fc3eab9f8b1aab22b40367a811",
            "glog-pfp-ruleFileCode/v1": "6bf91dc6b748fd226d1d4d6fc46ff2cdafa5319cb7eb6dc2122fe20b2d47e360"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6bf91dc6b748fd226d1d4d6fc46ff2cdafa5319cb7eb6dc2122fe20b2d47e360"
          }
        },
        {
          "ruleId": "40486eef-b7b1-333f-b81f-8dd2868526d2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.api.jwt.JwtUserController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtUserController.java"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 9,
                  "endLine": 38,
                  "endColumn": 40,
                  "snippet": {
                    "text": "Search search = new Search(text)"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "search(String)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtUserController.search(String)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "6251cda77c41af5fe746da0c4e8771d4b95688a183287624650201f20e3155c6",
            "glog-pfp-ruleFileCode/v1": "d45aef1fbfacb2237ef09ff6e5ca062308c5da3cb3d2ad3814347553c4a05c4c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d45aef1fbfacb2237ef09ff6e5ca062308c5da3cb3d2ad3814347553c4a05c4c"
          }
        },
        {
          "ruleId": "7c9cafe5-059c-3e94-b5a8-f189533e6f41",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.AdminController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/AdminController.java"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 15,
                  "endLine": 34,
                  "endColumn": 48,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Companies\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "companies(Model)",
                  "fullyQualifiedName": "hawk.controller.AdminController.companies(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "66ff0d1d472819598fd99a9f5598e2ce3bf6ae62dfc3a918da0da8a073760ef7",
            "glog-pfp-ruleFileCode/v1": "89e19b611242484d9b6bcf9d514e21bc7036fca2964f3fca2337f6a263e9e4d7"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "89e19b611242484d9b6bcf9d514e21bc7036fca2964f3fca2337f6a263e9e4d7"
          }
        },
        {
          "ruleId": "deabf0da-e8d4-3dd5-a80f-be0e920e77b5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.AdminController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/AdminController.java"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 15,
                  "endLine": 22,
                  "endColumn": 44,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Admin\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "index(Model)",
                  "fullyQualifiedName": "hawk.controller.AdminController.index(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c004862eda6d4d56200583d778c3f7335de31bf30cdec2a1cee2b561a533287a",
            "glog-pfp-ruleFileCode/v1": "eac14df9ed87424f33b3faf7880a1ce7fefb8ea1863c6d91917d481bccb5bd70"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "eac14df9ed87424f33b3faf7880a1ce7fefb8ea1863c6d91917d481bccb5bd70"
          }
        },
        {
          "ruleId": "6067bb0c-447a-31b2-b796-9a6252877b16",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Unreliable HTTP Headers Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtTokenProvider.java"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 9,
                  "endLine": 67,
                  "endColumn": 59,
                  "snippet": {
                    "text": "String bearerToken = req.getHeader(\"Authorization\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "resolveToken(HttpServletRequest)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtTokenProvider.resolveToken(HttpServletRequest)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ad9bc0cf3e5d5feb25a10317625e6066b159f0a4ecd2b5cd762e21f30192041f",
            "glog-pfp-ruleFileCode/v1": "fba48c97e9e1f011dff74c2c3559eab33b500a2cf79c49e0314d2f4903606d77"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fba48c97e9e1f011dff74c2c3559eab33b500a2cf79c49e0314d2f4903606d77"
          }
        },
        {
          "ruleId": "19453c2b-f009-3b5e-a8b6-a1449264eb96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.AdminController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/AdminController.java"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 15,
                  "endLine": 40,
                  "endColumn": 50,
                  "snippet": {
                    "text": "addAttribute(\"search\", new Search())"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "searchForm(Model)",
                  "fullyQualifiedName": "hawk.controller.AdminController.searchForm(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "6096aa8034ee1dd4aaeb70f0d19715f5b6c565f3c856f5707cb29bb423829c7f",
            "glog-pfp-ruleFileCode/v1": "b7437fc72706b8f821ca23cd3a0212e83a3184b088baf5299a7e07f708c0c765"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b7437fc72706b8f821ca23cd3a0212e83a3184b088baf5299a7e07f708c0c765"
          }
        },
        {
          "ruleId": "b7a82088-bd5e-3fdd-a445-4bc81366f8da",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.AdminController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/AdminController.java"
                },
                "region": {
                  "startLine": 47,
                  "endLine": 51,
                  "snippet": {
                    "text": "List users = userSearchService.search(search)"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "searchSubmit(Search, Model)",
                  "fullyQualifiedName": "hawk.controller.AdminController.searchSubmit(Search, Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "91bfb8f46f4d2b2dbb2b1be8c6abf1d55289f49485dbcfe283b67538a848f7ef",
            "glog-pfp-ruleFileCode/v1": "e5a325b8bc10786a198906c048ecafb3ed7fdfaf4302718d6c1f4f24d0dbb483"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "e5a325b8bc10786a198906c048ecafb3ed7fdfaf4302718d6c1f4f24d0dbb483"
          }
        },
        {
          "ruleId": "810396fb-fe08-3ef9-a2ee-4bcb84273bae",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.AdminController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/AdminController.java"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 15,
                  "endLine": 28,
                  "endColumn": 44,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Users\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "users(Model)",
                  "fullyQualifiedName": "hawk.controller.AdminController.users(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b8a3384be793f39428df2c13754e2959aba83a5ed4d1d986fa843cf4c1b8eb09",
            "glog-pfp-ruleFileCode/v1": "23c93f69409d8543baf7258fdc3cc3929b071255423da4c1229d02017e3c3050"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "23c93f69409d8543baf7258fdc3cc3929b071255423da4c1229d02017e3c3050"
          }
        },
        {
          "ruleId": "2bf81a81-58d8-3b9d-b949-ee19c32b807d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.HiddenController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/HiddenController.java"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 15,
                  "endLine": 25,
                  "endColumn": 87,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Hidden Page, found and tested with cypress tests\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "cypress(Model)",
                  "fullyQualifiedName": "hawk.controller.HiddenController.cypress(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b50a14849e5963837c2f863f1afad88d7ecbd7702cdeb6be1d5e71b78245f0e2",
            "glog-pfp-ruleFileCode/v1": "27f886ddac35cb6a5d21190fd5e46e2485ce5d07ce7bb96b841f173eb6f50585"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "27f886ddac35cb6a5d21190fd5e46e2485ce5d07ce7bb96b841f173eb6f50585"
          }
        },
        {
          "ruleId": "666b7120-9472-3e04-a083-36a7607f3baf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.HiddenController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/HiddenController.java"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 15,
                  "endLine": 19,
                  "endColumn": 47,
                  "snippet": {
                    "text": "addAttribute(\"Rando hidden page\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "hidden(Model)",
                  "fullyQualifiedName": "hawk.controller.HiddenController.hidden(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "74397e8280322ecb6430219e8a1e8e6c888474e311e5dd5ae670399ecf348c6d",
            "glog-pfp-ruleFileCode/v1": "c85e061642c79ccf98345e9c8862bd0e570778cf1ac3ca5f65635ea309af08de"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c85e061642c79ccf98345e9c8862bd0e570778cf1ac3ca5f65635ea309af08de"
          }
        },
        {
          "ruleId": "f6a81377-dc72-37b4-8063-248b2e6d184b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.HiddenController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/HiddenController.java"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 15,
                  "endLine": 37,
                  "endColumn": 90,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Hidden Page, found and tested with playwright tests\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "playwright(Model)",
                  "fullyQualifiedName": "hawk.controller.HiddenController.playwright(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "78cacae544affa809a22594ac9c1773db7b46e97fdc6f5baa5a632be16ebb026",
            "glog-pfp-ruleFileCode/v1": "65ac28788b3fb68d6049823c0187988fcc5f03e6e387233a80cdc36711b1f4ff"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "65ac28788b3fb68d6049823c0187988fcc5f03e6e387233a80cdc36711b1f4ff"
          }
        },
        {
          "ruleId": "fe9aa732-4c49-36cc-880e-0bc26fb47ec7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.HiddenController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/HiddenController.java"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 15,
                  "endLine": 31,
                  "endColumn": 88,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Hidden Page, found and tested with selenium tests\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "selenium(Model)",
                  "fullyQualifiedName": "hawk.controller.HiddenController.selenium(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9ed2624372237e865eb78ef22d91078a6a8b45bb3e65981720d2436f086b5660",
            "glog-pfp-ruleFileCode/v1": "34434b307f06a1101175f4c455b1c5d6508738d72191e4ed3dae92b0f6141f3c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "34434b307f06a1101175f4c455b1c5d6508738d72191e4ed3dae92b0f6141f3c"
          }
        },
        {
          "ruleId": "7637adb5-8381-3f60-95bb-bffc12d78a25",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.HiddenController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/HiddenController.java"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 15,
                  "endLine": 13,
                  "endColumn": 50,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Hidden Page\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "index(Model)",
                  "fullyQualifiedName": "hawk.controller.HiddenController.index(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "30244cf514358ea705c225b2ea46983a16b6f0d6391541f8ff062dc50835a48e",
            "glog-pfp-ruleFileCode/v1": "a5f7eccc61b05d8565869f0f0ec2bc34dd2e89dcc8607048aa9505dd2f7c9db2"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a5f7eccc61b05d8565869f0f0ec2bc34dd2e89dcc8607048aa9505dd2f7c9db2"
          }
        },
        {
          "ruleId": "de6afc69-2393-3eba-aeca-ced9207a260a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.IndexController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/IndexController.java"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 15,
                  "endLine": 12,
                  "endColumn": 71,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"StackHawk Java Vulny Application\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "index(Model)",
                  "fullyQualifiedName": "hawk.controller.IndexController.index(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b6204f2644c49a073f2803ef32094f2bf24cbb0667ddbd57f3977b5e12dcc25d",
            "glog-pfp-ruleFileCode/v1": "45b851d7ba6cd8b56d5486d61391cbdd30525695953de9b49083812b87017146"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "45b851d7ba6cd8b56d5486d61391cbdd30525695953de9b49083812b87017146"
          }
        },
        {
          "ruleId": "72bea607-7af1-3225-9002-5306a33caef1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.IndexController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/IndexController.java"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 15,
                  "endLine": 18,
                  "endColumn": 47,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"JWT Auth\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "jwtAuth(Model)",
                  "fullyQualifiedName": "hawk.controller.IndexController.jwtAuth(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "3fa8601fcf05b27a0ff2ceb5700d334ba5e9ece4a026f38b2884101aef422286",
            "glog-pfp-ruleFileCode/v1": "cd4373ee22aec106056ad05d4096459c5150e7c62ce1df8adb5fb91dfdb24ba7"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cd4373ee22aec106056ad05d4096459c5150e7c62ce1df8adb5fb91dfdb24ba7"
          }
        },
        {
          "ruleId": "346a775d-6fa0-3016-8317-f51a06186c61",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.IndexController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/IndexController.java"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 15,
                  "endLine": 30,
                  "endColumn": 49,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Basic Auth\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "basicAuth(Model)",
                  "fullyQualifiedName": "hawk.controller.IndexController.basicAuth(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7b19ee393bfc29c63d648665eee2e244c515bda7d2d5435ce4ce046f5db672a1",
            "glog-pfp-ruleFileCode/v1": "a29e6145d1c05f7c56517f0904d4b6e306438217ce7e776dcbd442816f2fbe9e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a29e6145d1c05f7c56517f0904d4b6e306438217ce7e776dcbd442816f2fbe9e"
          }
        },
        {
          "ruleId": "0936592b-bc07-338f-b97f-b04cc765c590",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.LoginController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/LoginController.java"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 15,
                  "endLine": 46,
                  "endColumn": 50,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Login title\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "login(Model)",
                  "fullyQualifiedName": "hawk.controller.LoginController.login(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7e40b83fcccd27ec7744eaee46cc355fb0baa14d0a5182cfe9543b990fe29d01",
            "glog-pfp-ruleFileCode/v1": "964455e7ba76180440db48408d87fa2343ad0afb1f1b51a4e5c9df828c4f97f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "964455e7ba76180440db48408d87fa2343ad0afb1f1b51a4e5c9df828c4f97f1"
          }
        },
        {
          "ruleId": "c488398d-6373-300e-9674-8539eae45250",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.IndexController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/IndexController.java"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 15,
                  "endLine": 24,
                  "endColumn": 49,
                  "snippet": {
                    "text": "addAttribute(\"title\", \"Token Auth\")"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "tokenAuth(Model)",
                  "fullyQualifiedName": "hawk.controller.IndexController.tokenAuth(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c6087ff60c1a444b05278f1994cdc2d5dbe08b7c54857aa7134dc8dccd5922bc",
            "glog-pfp-ruleFileCode/v1": "329887d812774938ebdee16bd4714f0519d6b02c5949dfea7cdd9f7be222a611"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "329887d812774938ebdee16bd4714f0519d6b02c5949dfea7cdd9f7be222a611"
          }
        },
        {
          "ruleId": "2ff77974-10f7-39fd-bb4d-2976ff215572",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.LoginController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/LoginController.java"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 9,
                  "endLine": 54,
                  "endColumn": 48,
                  "snippet": {
                    "text": "String sessId = req.getSession().getId()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "loginCode(HttpServletRequest, HttpServletResponse, Model)",
                  "fullyQualifiedName": "hawk.controller.LoginController.loginCode(HttpServletRequest, HttpServletResponse, Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d9f57974792b8ec7cce0379a42712fedcc843e4ddbb288d85781dca7f0fec633",
            "glog-pfp-ruleFileCode/v1": "956340cef364d953b4a96463e87b2b5ec764ae0781b7aa6a1cd041c2da909953"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "956340cef364d953b4a96463e87b2b5ec764ae0781b7aa6a1cd041c2da909953"
          }
        },
        {
          "ruleId": "74a4a50f-e064-310c-b6a1-297fb3c6e945",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.LoginController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/LoginController.java"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 13,
                  "endLine": 79,
                  "endColumn": 52,
                  "snippet": {
                    "text": "String sessId = req.getSession().getId()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "loginFormMulti(HttpServletRequest, HttpServletResponse, String, ExtraAuthenticationRequest)",
                  "fullyQualifiedName": "hawk.controller.LoginController.loginFormMulti(HttpServletRequest, HttpServletResponse, String, ExtraAuthenticationRequest)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "187575a0ecec82121045c1a3e37233acc494dfc0c55a08bd307b861f7670399e",
            "glog-pfp-ruleFileCode/v1": "e356d05eadb714d01a0dd393f686a5e8b28af5bb788013cce9ce76e278382fa4"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "e356d05eadb714d01a0dd393f686a5e8b28af5bb788013cce9ce76e278382fa4"
          }
        },
        {
          "ruleId": "866102c1-8960-3baa-8720-83f1f7ece441",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.LoginController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/LoginController.java"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 9,
                  "endLine": 110,
                  "endColumn": 48,
                  "snippet": {
                    "text": "String sessId = req.getSession().getId()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "loginCheck(HttpServletRequest, HttpServletResponse, Model, String)",
                  "fullyQualifiedName": "hawk.controller.LoginController.loginCheck(HttpServletRequest, HttpServletResponse, Model, String)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "0463fa5b5df7d13b244c7a9aba3c1ee706cf78d620648aef34162d33a2af5237",
            "glog-pfp-ruleFileCode/v1": "1d4801a0af368cf83c694e1058c40eef29d60679a6bcd03b3ca9fdc6c5131aac"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "1d4801a0af368cf83c694e1058c40eef29d60679a6bcd03b3ca9fdc6c5131aac"
          }
        },
        {
          "ruleId": "c61bac12-7018-39c5-a0a5-53b13751916e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.LoginController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/LoginController.java"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 9,
                  "endLine": 63,
                  "endColumn": 48,
                  "snippet": {
                    "text": "String sessId = req.getSession().getId()"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "loginFormMulti(HttpServletRequest, Model)",
                  "fullyQualifiedName": "hawk.controller.LoginController.loginFormMulti(HttpServletRequest, Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "62844d86ac93fd755c855137d90da7f9c73f3dd4eb7d0c7c746bfb95cd360b55",
            "glog-pfp-ruleFileCode/v1": "52b55209c4c59dc00868661da64d025c4e4d2c4ed26f9a4130b938c905f099e8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "52b55209c4c59dc00868661da64d025c4e4d2c4ed26f9a4130b938c905f099e8"
          }
        },
        {
          "ruleId": "de285b0f-d98a-3a90-98e5-02c0c7278049",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.PayloadController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/PayloadController.java"
                },
                "region": {
                  "startLine": 34,
                  "endLine": 42,
                  "snippet": {
                    "text": "if (PayloadController.payloadCache.containsKey(size))"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "getPayload(Model, Integer)",
                  "fullyQualifiedName": "hawk.controller.PayloadController.getPayload(Model, Integer)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5c2c8a71e8a2dbb7be7c7e8873f2949f1fec9f88c48603e6da957fa0f6ddb02c",
            "glog-pfp-ruleFileCode/v1": "72c684d24296be8b91ca63739d5faaab8fc273fdaa801051dbe485c235cd63a8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "72c684d24296be8b91ca63739d5faaab8fc273fdaa801051dbe485c235cd63a8"
          }
        },
        {
          "ruleId": "f0d6dca5-8af7-356b-94be-72a2b2674733",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.PayloadController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/PayloadController.java"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 9,
                  "endLine": 47,
                  "endColumn": 58,
                  "snippet": {
                    "text": "Integer[] payloadSizes = new Integer[payloadCount]"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "getPayloadsList(Model)",
                  "fullyQualifiedName": "hawk.controller.PayloadController.getPayloadsList(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d0b06c318aa093e967e09660b29168da19d4dc995c263f62a04c00411b262cd6",
            "glog-pfp-ruleFileCode/v1": "9216e62c74d733987886456e30b35c7f892994a2c2d620e1328f29bc1d2288fe"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9216e62c74d733987886456e30b35c7f892994a2c2d620e1328f29bc1d2288fe"
          }
        },
        {
          "ruleId": "901e68dc-4f2f-3c07-884a-c4cddfc5c6bc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.SearchController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/SearchController.java"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 15,
                  "endLine": 31,
                  "endColumn": 50,
                  "snippet": {
                    "text": "addAttribute(\"search\", new Search())"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "searchForm(Model)",
                  "fullyQualifiedName": "hawk.controller.SearchController.searchForm(Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1de18b5047fb4866a4e8b63b6ad1637dbf1f989d4949a128aa9de4c2de4dc285",
            "glog-pfp-ruleFileCode/v1": "aa70bdecf6674655307a61e527de58c95f6d256a3594abe495697058b1fadcf1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "aa70bdecf6674655307a61e527de58c95f6d256a3594abe495697058b1fadcf1"
          }
        },
        {
          "ruleId": "366256ef-be6e-352c-be3f-f013fce16efd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.controller.SearchController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/SearchController.java"
                },
                "region": {
                  "startLine": 38,
                  "endLine": 42,
                  "snippet": {
                    "text": "List items = searchService.search(search)"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "searchSubmit(Search, Model)",
                  "fullyQualifiedName": "hawk.controller.SearchController.searchSubmit(Search, Model)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "d7b7e131d1b0397c9b9c38af72dc3754e33452bb55cf7a34c6bff2d3cc386e2e",
            "glog-pfp-ruleFileCode/v1": "9bc0085d9d3f1d61e15e4126a2583c3041290b9a772c33219888a57ede2a274b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9bc0085d9d3f1d61e15e4126a2583c3041290b9a772c33219888a57ede2a274b"
          }
        },
        {
          "ruleId": "b3a0450a-084e-3032-95c9-ca960b865707",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Found Spring endpoint",
            "id": "default",
            "arguments": [
              "hawk.api.jwt.JwtUserController"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/jwt/JwtUserController.java"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 9,
                  "endLine": 44,
                  "endColumn": 40,
                  "snippet": {
                    "text": "Search search = new Search(text)"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "searchCrappy(String)",
                  "fullyQualifiedName": "hawk.api.jwt.JwtUserController.searchCrappy(String)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "8af0d9bf399d87470cf6545130a19253bfa8e2c349b4a33978a65feef4b88c0b",
            "glog-pfp-ruleFileCode/v1": "cfb3be23f40c523a1fe5ea22539d2d0a1cb735ee58bd06f3399babc3cbb78271"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cfb3be23f40c523a1fe5ea22539d2d0a1cb735ee58bd06f3399babc3cbb78271"
          }
        },
        {
          "ruleId": "0c33f4e9-6f80-3ed4-abb1-38558b9ef925",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Unreliable HTTP Headers Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/api/token/TokenFilter.java"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 9,
                  "endLine": 17,
                  "endColumn": 49,
                  "snippet": {
                    "text": "return request.getHeader(authHeaderName);"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "getPreAuthenticatedPrincipal(HttpServletRequest)",
                  "fullyQualifiedName": "hawk.api.token.TokenFilter.getPreAuthenticatedPrincipal(HttpServletRequest)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e34a7e9e7e04b6446c62786fe16c1df66a58b34c4301395485cd260f228c03eb",
            "glog-pfp-ruleFileCode/v1": "725f8d460ada158b93a0b58748dc25c785fdbfd06449207229831e826a46f563"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "725f8d460ada158b93a0b58748dc25c785fdbfd06449207229831e826a46f563"
          }
        },
        {
          "ruleId": "a3a14f30-d332-32a2-8bbc-e79e3ff8a6ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Violation of Trust Boundary"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/LoginController.java"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 21,
                  "endLine": 100,
                  "endColumn": 65,
                  "snippet": {
                    "text": "setAttribute(SPRING_SECURITY_CONTEXT_KEY, sc)"
                  }
                }
              },
              "logicalLocations": [
                {
                  "name": "loginFormMulti(HttpServletRequest, HttpServletResponse, String, ExtraAuthenticationRequest)",
                  "fullyQualifiedName": "hawk.controller.LoginController.loginFormMulti(HttpServletRequest, HttpServletResponse, String, ExtraAuthenticationRequest)",
                  "kind": "function"
                }
              ]
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "26c1642b035df4d7afc5e3503f97be627eab2feb0eefa2cd9338da73e2d86b33",
            "glog-pfp-ruleFileCode/v1": "c8e6bf94d1fa5e5c7ee1ded621f580cce0cf08b32e3df856bef088e85aceccfc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c8e6bf94d1fa5e5c7ee1ded621f580cce0cf08b32e3df856bef088e85aceccfc"
          }
        },
        {
          "ruleId": "10fb63e3-85d0-347e-9e79-c3419a3b0650",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "'HttpOnly' flag not set for cookie vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/java/hawk/controller/LoginController.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 9,
                  "endLine": 57,
                  "endColumn": 60,
                  "snippet": {
                    "text": "        resp.addCookie(new Cookie(\"XLOGINID\", cookieCode));"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "54a906d495c6e2c549b989d7c5d037ef82dc013d57d07f029ac98b39121dcec7",
            "glog-pfp-ruleFileCode/v1": "ebd1393711ab07b860d4a9239ddcae8b69d18a7e418c770dc7ed320f32d038e9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ebd1393711ab07b860d4a9239ddcae8b69d18a7e418c770dc7ed320f32d038e9"
          },
          "properties": {}
        },
        {
          "ruleId": "6874cf9b-e97b-39bc-8156-8ff0d1172299",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "XSS Vulnerability from User-Controlled Data in HTML String"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "hawkscripts/authentication/form-auth-multi.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 3,
                  "endLine": 48,
                  "endColumn": 68,
                  "snippet": {
                    "text": "  return `${hawkConf[\"app\"][\"host\"]}${paramsValues.get(paramName)}`"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fe63742e2f8d92695c776dd52122df33f3250e0f6f43c118cd0a531934d4f9e8",
            "glog-pfp-ruleFileCode/v1": "1bef8c42bf9fd248ff79a488b54430f444ac9667fa3984f53981e6afe7adc56b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "1bef8c42bf9fd248ff79a488b54430f444ac9667fa3984f53981e6afe7adc56b"
          },
          "properties": {}
        },
        {
          "ruleId": "c715549b-a9b6-3a33-b131-6d91bbc2d851",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "XSS Vulnerability from User-Controlled Data in HTML String"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "hawkscripts/authentication/form-auth-multi.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 5,
                  "endLine": 59,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    str += `${urlEncode(key)}=${urlEncode(obj[key])}`;"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "46c0708921fb21867f6bbef56108d8e6c6a26dc949dc4573f62220936a16cb5e",
            "glog-pfp-ruleFileCode/v1": "12cb9afa6ea742d7638207bfb0c811e06d4935b4fad2d4500ca741629c8c236e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "12cb9afa6ea742d7638207bfb0c811e06d4935b4fad2d4500ca741629c8c236e"
          },
          "properties": {}
        },
        {
          "ruleId": "4923fc7d-94f8-3cc9-89f2-91769612e757",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "hawkscripts/authentication/form-auth-multi.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 139,
                  "startColumn": 3,
                  "endLine": 139,
                  "endColumn": 118,
                  "snippet": {
                    "text": "  return `${msg.requestHeader}\\r\\n\\r\\n${msg.requestBody}\\r\\n---\\r\\n${msg.responseHeader}\\r\\n\\r\\n${msg.responseBody}`;"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "35c09933adf825c6ae1524f096406251cffab0fb3feea4aba7a7d01427f72809",
            "glog-pfp-ruleFileCode/v1": "fd48250c61bc770267710a06698f6a8f9ef1518f1ada4c28adc506d0ffd9cb42"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fd48250c61bc770267710a06698f6a8f9ef1518f1ada4c28adc506d0ffd9cb42"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}